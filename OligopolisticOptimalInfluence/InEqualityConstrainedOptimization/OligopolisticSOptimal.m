function [SA,S1,S2,SB] = OligopolisticSOptimal(T1_A,T2_A,T1_B,T2_B,Lambda_A_1,Lambda_A_2,Lambda_B_1,Lambda_B_2,Theta1,Theta2)

% This function returns the optimal limiting influences SA, S1, S2 and SB
% with respect to the optimal T1_A, T2_A, T1_B and T2_B given Lambda_A_1,  
% Lambda_A_2, Lambda_B_1, Lambda_B_2, Theta1 and Theta2. Quantities T1_A, 
% T2_A, T1_B and T2_B are the optimal quantities obtained from the 
% minimization process. This entails that the computed influence values are
% also the optimal ones.

% Mind that all four quantities SA,S1,S2 and SB share the same denominator.
% Let that denominator be denoted as D and the corresponding four numerators 
% be denoted as NA, N1, N2 and NB. Therefore, the final expressions
%  for the aforementioned quantities will be given as:
%                     SA = NA / D
%                     S1 = N1 / D
%                     S2 = N2 / D
%                     SB = NB / D
D = Lambda_A_1*Lambda_B_1*T2_A + Lambda_A_2*Lambda_B_1*T1_A + ...
        Lambda_A_1*Lambda_B_1*T2_B + Lambda_A_1*Lambda_B_2*T1_B + ...
        Lambda_A_1*Lambda_B_2*T2_A + Lambda_A_2*Lambda_B_2*T1_A + ...
        Lambda_A_2*Lambda_B_1*T2_B + Lambda_A_2*Lambda_B_2*T1_B + ...
        Lambda_A_1*Lambda_B_1*Theta1 + Lambda_A_1*Lambda_B_1*Theta2 + ...
        Lambda_A_1*Lambda_B_2*Theta1 + Lambda_A_2*Lambda_B_1*Theta1 + ...
        Lambda_A_1*Lambda_B_2*Theta2 + Lambda_A_2*Lambda_B_1*Theta2 + ...
        Lambda_A_2*Lambda_B_2*Theta1 + Lambda_A_2*Lambda_B_2*Theta2 + ...
        Lambda_A_1*T1_B*T2_A + Lambda_B_1*T1_A*T2_A + Lambda_A_1*T1_B*T2_B ...
      + Lambda_A_2*T1_A*T2_B + Lambda_B_1*T1_A*T2_B + Lambda_B_2*T1_A*T2_A ...
      + Lambda_A_2*T1_B*T2_B + Lambda_B_2*T1_B*T2_A + Lambda_A_1*T1_B*Theta1 ...
      + Lambda_B_1*T1_A*Theta1 + Lambda_A_2*T1_B*Theta1 + Lambda_B_2*T1_A*Theta1 ...
      + Lambda_A_1*T2_B*Theta2 + Lambda_B_1*T2_A*Theta2 + Lambda_A_2*T2_B*Theta2 ...
      + Lambda_B_2*T2_A*Theta2;

  
NA = Lambda_B_1*T1_A*T2_A + Lambda_B_1*T1_A*T2_B + Lambda_B_2*T1_A*T2_A + ...
     Lambda_B_2*T1_B*T2_A + Lambda_B_1*T1_A*Theta1 + Lambda_B_2*T1_A*Theta1 + ...
     Lambda_B_1*T2_A*Theta2 + Lambda_B_2*T2_A*Theta2;
 
N1 = Lambda_A_1*Lambda_B_1*T2_A + Lambda_A_1*Lambda_B_1*T2_B + ...
     Lambda_A_1*Lambda_B_2*T2_A + Lambda_A_2*Lambda_B_1*T2_B + ...
     Lambda_A_1*Lambda_B_1*Theta1 + Lambda_A_1*Lambda_B_2*Theta1 + ...
     Lambda_A_2*Lambda_B_1*Theta1 + Lambda_A_2*Lambda_B_2*Theta1;

N2 = Lambda_A_2*Lambda_B_1*T1_A + Lambda_A_1*Lambda_B_2*T1_B + ...
     Lambda_A_2*Lambda_B_2*T1_A + Lambda_A_2*Lambda_B_2*T1_B + ...
     Lambda_A_1*Lambda_B_1*Theta2 + Lambda_A_1*Lambda_B_2*Theta2 + ...
     Lambda_A_2*Lambda_B_1*Theta2 + Lambda_A_2*Lambda_B_2*Theta2; 
 
NB = Lambda_A_1*T1_B*T2_A + Lambda_A_1*T1_B*T2_B + Lambda_A_2*T1_A*T2_B + ...
     Lambda_A_2*T1_B*T2_B + Lambda_A_1*T1_B*Theta1 + Lambda_A_2*T1_B*Theta1 + ...
     Lambda_A_1*T2_B*Theta2 + Lambda_A_2*T2_B*Theta2;
 
% Final computation of the constituent values of the optimal influences vector.
SA = NA / D;
S1 = N1 / D;
S2 = N2 / D;
SB = NB / D;

end

